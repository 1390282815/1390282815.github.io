<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>动规笔记P2051中国象棋</title>
      <link href="/2019/04/21/%E5%8A%A8%E8%A7%84%E7%AC%94%E8%AE%B0P2051%E4%B8%AD%E5%9B%BD%E8%B1%A1%E6%A3%8B/"/>
      <url>/2019/04/21/%E5%8A%A8%E8%A7%84%E7%AC%94%E8%AE%B0P2051%E4%B8%AD%E5%9B%BD%E8%B1%A1%E6%A3%8B/</url>
      
        <content type="html"><![CDATA[<p>#动规笔记</p><p>##————P2051 中国象棋</p><h2 id="题目"><a href="#题目" class="headerlink" title="##题目"></a>##<a href="https://www.luogu.org/problemnew/show/P2051" target="_blank" rel="noopener">题目</a></h2><p>#提取信息<br>     有一个(n , m)的棋盘在其中h放置棋子，每行每列不超过2个，有多少种放法</p><p>#解法</p><p>###1.暴力</p><p>###2.状压</p><p>###3.正解</p><p>#暴力<br>     暴力枚举，30pt。</p><p>#状压<br>     不是很适合，要用3进制状压，且状态与之前所有行有关联，3^100是压不动的。</p><pre><code>可以拿50pt。</code></pre><p>#正解<br>     可以发现前i - 1行，棋子摆放的位置是不会影响到第i行的决策，</p><pre><code>有影响的只有前i行，有多少列棋子数为0 ，1 ，2。可设出状态f[i//放了i行的棋子][j//棋子数为1的列的个数][k//棋子数为2的列的个数]之后的转移方程就比较容易推了，在第i行，考虑放0 ，1 ，2个棋子，放在棋子数为0 ，1 ，2的列中。具体看代码：</code></pre><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> #include&lt;bits/stdc++.h&gt;</span><br><span class="line"> #define FOR(a , b , c) for (int a = b; a &lt;= c; a++)</span><br><span class="line"> using namespace std;</span><br><span class="line"> const int M = 9999973;</span><br><span class="line"> long long n , m , ans , f[107][107][107];</span><br><span class="line"> int main () &#123;</span><br><span class="line"> scanf (&quot;%lld %lld&quot; , &amp;n , &amp;m);</span><br><span class="line"> f[0][0][0] = 1; //初始化</span><br><span class="line"> FOR(i , 1 , n) FOR(j , 0 , m) FOR(k , 0 , m - j) &#123;</span><br><span class="line">  f[i][j][k] += f[i - 1][j][k]; //不放棋子</span><br><span class="line">  if (j &gt;= 1) f[i][j][k] += ((m - (j - 1) - k) * f[i - 1][j - 1][k]) % M; //放一个在棋子数为0的列</span><br><span class="line">  if (j + 1 &lt;= m &amp;&amp; k &gt;= 1) f[i][j][k] += ((j + 1) * f[i - 1][j + 1][k - 1]) % M; //放一个在棋子数为1的列</span><br><span class="line">  if (j &gt;= 2) f[i][j][k] += (((m - (j - 2) - k) * (m - (j - 1) - k) / 2) * f[i - 1][j - 2][k]) % M; //放二个棋子都在棋子数为0的列</span><br><span class="line">  if (j + 2 &lt;= m &amp;&amp; k &gt;= 2) f[i][j][k] += (((j + 2) * (j + 1) / 2) * f[i - 1][j + 2][k - 2]) % M; //放二个棋子都在棋子数为1的列</span><br><span class="line">  if (k &gt;= 1 &amp;&amp; j &gt;= 1) f[i][j][k] += (j * (m - (j - 1) - k) * f[i - 1][j][k - 1]) % M;</span><br><span class="line"> &#125; //放二个棋子在棋子数为0 ，1的列</span><br><span class="line"> FOR(j , 0 , m) FOR(k , 0 , m - j) ans = (ans + f[n][j][k]) % M; //取进行到n行的所有状态</span><br><span class="line"> printf (&quot;%lld&quot; , ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>#后记分析<br>     很像状压，陷进去可能出不来。</p><pre><code>对于状态的考虑很重要。dp时的小细节，不能出界。</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 动规笔记 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
